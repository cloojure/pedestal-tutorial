(ns util
  (:require 
    [tupelo.core :as t]))
(t/refer-tupelo)

(defmacro vals->context ; #todo -> README
  "Called with a list of symbols like `(vals->context a b c)` returns a map
   like {:a a :b b :c c}.

       (let [a 1
             b 2
             c 3]
         (vals->context a b c))  ;=>  {:a 1 :b 2 :c 3} }

   See `with-context` for simple destructuring of such maps."
  [& symbols]
  (let [map-vec (forv [symbol symbols]
                  {(keyword symbol) symbol})]
    `(glue ~@map-vec) ) )

; #todo: rename with-labeled-map
(defmacro with-context ; #todo -> README
  "Given a map like {:a 1 :b 2 :c 3} (such as generated by `(vals->context a b c)`),
  performs safe `let` destructuring using `grab` like:

     (let [some-map  {:a 1 :b 2 :c 3} } ]
       (with-context some-map [a b c]
          (+ a b c)))  ;=>  6

  `with-context` is safe for typos since `grab` will throw is the requrested map key is not present.
  See `vals->context` for simple creation of labelled data maps."
  [ the-map items-vec & forms]
  `(do
     ; (assert (map? ~the-map))
     ; (assert (sequential? ~items-vec))
     (let  ; generate the binding vector dynamically
       ~(apply glue
          (for [item items-vec
                :let [sym (symbol (name item))
                      kw  (keyword item)]]
            [sym (list 'grab kw the-map)]))
       ~@forms)))
